(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{393:function(e,t,a){"use strict";a.r(t);var o=a(42),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"setting-api-service-levels"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setting-api-service-levels"}},[e._v("#")]),e._v(" Setting API service levels")]),e._v(" "),a("p",[a("strong",[e._v("Optimise your API service level indicators based on your user needs.")])]),e._v(" "),a("p",[e._v("When managing your API as a service, you need to understand what matters to your users and what you’ll commit to in your service level agreement. You may want to consider:")]),e._v(" "),a("ul",[a("li",[e._v("request latency")]),e._v(" "),a("li",[e._v("system throughput")]),e._v(" "),a("li",[e._v("availability and downtime")])]),e._v(" "),a("p",[e._v("Each of these aspects is a service level indicator (SLI). This guidance describes different SLIs and how you can optimise them based on techniques that have worked for some government development teams. You should optimise your SLIs based on your number of API users and their needs.")]),e._v(" "),a("p",[e._v("High service levels can be expensive to deliver, so you should not set them higher than necessary.")]),e._v(" "),a("h2",{attrs:{id:"establishing-the-best-request-latency-for-your-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#establishing-the-best-request-latency-for-your-api"}},[e._v("#")]),e._v(" Establishing the best request latency for your API")]),e._v(" "),a("p",[e._v("One of the most important SLIs to agree is how long it takes an API request to return a response.")]),e._v(" "),a("p",[e._v("Engineering an API for a higher performance in request latency than your users need can be expensive, so you need to make an assessment about the context you’re working in. For example, a train network API must be able to provide data about train whereabouts in real time or suffer severe consequences. However, a tax API may not need to process tax returns so quickly.")]),e._v(" "),a("p",[e._v("To improve your API latency, you may want to consider:")]),e._v(" "),a("ul",[a("li",[e._v("installing a content delivery network")]),e._v(" "),a("li",[e._v("engineering a backend heavy-lifting data query API to pick up large amounts of data infrequently matched with a ‘chatty’ frontend API to pick up smaller amounts of data frequently")]),e._v(" "),a("li",[e._v("caching your API data - consider making GET requests cacheable to avoid forcing every API call to create network traffic and hit your database")]),e._v(" "),a("li",[e._v("investing resources in data wrangling")])]),e._v(" "),a("p",[e._v("These approaches can decrease network costs and improve performance using the same hardware. However, all of these approaches will depend on how fresh your data needs to be. Your users may sometimes need to be able to access your API data during network interruptions when the data is unavailable from the servers.")]),e._v(" "),a("p",[e._v("When caching, you should:")]),e._v(" "),a("ul",[a("li",[e._v("cache as close to the user as possible - this stops requests causing any additional network activity")]),e._v(" "),a("li",[e._v("add Cache-Control or Vary HTTP headers - these will articulate your caching policy to your users, for example how a resource is cached, where it’s cached, and the maximum age it can reach before it expires")])]),e._v(" "),a("p",[e._v("If you have a volatile API, you should not cache by default.")]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),a("p",[e._v("You should never cache sensitive or user-specific data especially anything that would fall under the General Data Protection Regulation.")])]),e._v(" "),a("p",[e._v("When developing a data API (rather than a transactional API), you should consider whether to let users make large data requests or whether to restrict users to making a number of smaller requests. If you believe large data requests are necessary for your users, you may want to consider:")]),e._v(" "),a("ul",[a("li",[e._v("using data compression such as GZIP files - if your API is RESTful, let users send headers that say they will not accept compressed data")]),e._v(" "),a("li",[e._v("paginating requests - breaking your API resources into manageable chunks lets users make multiple requests rather than a single one")]),e._v(" "),a("li",[e._v("downloading data sets as CSV files periodically - taking snapshots of your data at regular periods and caching it for users to download is less resource-intensive than having users dynamically generate a CSV file from your active database")]),e._v(" "),a("li",[e._v("using operational data stores - this is useful if your data is in lots of different systems and you want to stage the data to make it readily accessible to user requests")])]),e._v(" "),a("p",[e._v("Staging data using operational data stores will timestamp your data. When using these techniques you’ll need to consider how often you sync the staged data with your master data sets.")]),e._v(" "),a("p",[e._v("Operational data stores may not be suitable for users of APIs who need the most up-to-date data available. Keeping an operational data store updated in real time is unlikely to be cost-effective.")]),e._v(" "),a("h2",{attrs:{id:"system-throughput-for-transactional-apis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#system-throughput-for-transactional-apis"}},[e._v("#")]),e._v(" System throughput for transactional APIs")]),e._v(" "),a("p",[e._v("System throughput is the number of requests that can be made to your API within a period of time. You may choose to apply ‘throttling’, or ‘rate limiting’ to set a limit on the number of requests applications can make to your API")]),e._v(" "),a("p",[e._v("If you have transactional APIs, you may choose to apply rate limiting to:")]),e._v(" "),a("ul",[a("li",[e._v("manage capacity and costs - transactional APIs have a high cost per request compared to data APIs because every transaction goes through the whole stack, and probably results in at least one database write")]),e._v(" "),a("li",[e._v("encourage responsible consumption")]),e._v(" "),a("li",[e._v("protect from denial-of-service (DoS) attacks")]),e._v(" "),a("li",[e._v("enforce a strict semantic defining which headers and values to use")])]),e._v(" "),a("p",[e._v("When applying rate limiting or throttling, you should not let your users go over the limits you set even if you have spare capacity. This is because if you need to take the spare capacity away in future and the user has developed their application with the higher rates in mind, their application could break. For the same reason, avoid retroactively enforcing rate-limiting caps.")]),e._v(" "),a("p",[e._v("When applying rate limiting to transactional APIs, you should:")]),e._v(" "),a("ul",[a("li",[e._v("clearly communicate with users - for example, use X-RateLimit_remaining in the header to let them know when they are close to your limit")]),e._v(" "),a("li",[e._v("understand performance limitations of backend systems - the backend system is usually the weakest link in terms of performance rather than the API")]),e._v(" "),a("li",[e._v("understand users may want to use your API a lot for a short period of time and this may be unpredictable - in these instances consider setting a burst limit")])]),e._v(" "),a("p",[e._v("When setting a burst limit, consider the volume of this facility. For example, your rate limit could be 10,000 requests per minute with a burst limit of 20,000 requests per minute for up to 5 minutes.")]),e._v(" "),a("p",[e._v("Refer to the government "),a("a",{attrs:{href:"/technology/api-standards"}},[e._v("API technical and data standards")]),e._v(" for more information on rate limiting.")]),e._v(" "),a("h2",{attrs:{id:"managing-your-api-availability-and-downtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#managing-your-api-availability-and-downtime"}},[e._v("#")]),e._v(" Managing your API availability and downtime")]),e._v(" "),a("p",[e._v("When considering SLIs around availability, you need to think about the kind of downtime that will be a problem for your API. For instance, your API could drop 1 in 20 connections or it could be unreachable for 2 hours a day. Both of these scenarios could result in the same percentage of uptime but one of them may be more problematic for users than the other.")]),e._v(" "),a("p",[e._v("You also need to make sure you balance the need for availability with the costs of achieving it. If users do not tend to use your API in the early hours of the morning then it makes sense to do API maintenance work at this time.")]),e._v(" "),a("p",[e._v("How you manage your API downtime will have implications for the cost of an on-call support team. You need to decide when it’s appropriate to pay a technology team overtime money to attend to your API downtime out of hours.")]),e._v(" "),a("p",[e._v("To improve the availability of your API you could consider scaling up your source system or putting a cache in front of it.")]),e._v(" "),a("p",[e._v("When designing a low-availability API, consider the use of HTTP 202 responses. For example, to indicate that the API has accepted a request but needs to wait to take further action.")])])}),[],!1,null,null,null);t.default=s.exports}}]);